/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/metaplex-foundation/kinobi
 */

import { Program, ProgramError } from '@metaplex-foundation/umi';

type ProgramErrorConstructor = new (
  program: Program,
  cause?: Error
) => ProgramError;
const codeToErrorMap: Map<number, ProgramErrorConstructor> = new Map();
const nameToErrorMap: Map<string, ProgramErrorConstructor> = new Map();

/** NumericalOverflow: 'Numerical Overflow' */
export class NumericalOverflowError extends ProgramError {
  readonly name: string = 'NumericalOverflow';

  readonly code: number = 0x0; // 0

  constructor(program: Program, cause?: Error) {
    super('Numerical Overflow', program, cause);
  }
}
codeToErrorMap.set(0x0, NumericalOverflowError);
nameToErrorMap.set('NumericalOverflow', NumericalOverflowError);

/** InvalidAccount: 'Invalid account' */
export class InvalidAccountError extends ProgramError {
  readonly name: string = 'InvalidAccount';

  readonly code: number = 0x1; // 1

  constructor(program: Program, cause?: Error) {
    super('Invalid account', program, cause);
  }
}
codeToErrorMap.set(0x1, InvalidAccountError);
nameToErrorMap.set('InvalidAccount', InvalidAccountError);

/** InvalidEscrowConstraintModel: 'Invalid Escrow Constraint Model' */
export class InvalidEscrowConstraintModelError extends ProgramError {
  readonly name: string = 'InvalidEscrowConstraintModel';

  readonly code: number = 0x2; // 2

  constructor(program: Program, cause?: Error) {
    super('Invalid Escrow Constraint Model', program, cause);
  }
}
codeToErrorMap.set(0x2, InvalidEscrowConstraintModelError);
nameToErrorMap.set(
  'InvalidEscrowConstraintModel',
  InvalidEscrowConstraintModelError
);

/** InvalidEscrowConstraint: 'Invalid Escrow Constraint' */
export class InvalidEscrowConstraintError extends ProgramError {
  readonly name: string = 'InvalidEscrowConstraint';

  readonly code: number = 0x3; // 3

  constructor(program: Program, cause?: Error) {
    super('Invalid Escrow Constraint', program, cause);
  }
}
codeToErrorMap.set(0x3, InvalidEscrowConstraintError);
nameToErrorMap.set('InvalidEscrowConstraint', InvalidEscrowConstraintError);

/** EscrowConstraintViolation: 'Escrow Constraint Violation' */
export class EscrowConstraintViolationError extends ProgramError {
  readonly name: string = 'EscrowConstraintViolation';

  readonly code: number = 0x4; // 4

  constructor(program: Program, cause?: Error) {
    super('Escrow Constraint Violation', program, cause);
  }
}
codeToErrorMap.set(0x4, EscrowConstraintViolationError);
nameToErrorMap.set('EscrowConstraintViolation', EscrowConstraintViolationError);

/** InvalidUpdateAuthority: 'Invalid Update Authority' */
export class InvalidUpdateAuthorityError extends ProgramError {
  readonly name: string = 'InvalidUpdateAuthority';

  readonly code: number = 0x5; // 5

  constructor(program: Program, cause?: Error) {
    super('Invalid Update Authority', program, cause);
  }
}
codeToErrorMap.set(0x5, InvalidUpdateAuthorityError);
nameToErrorMap.set('InvalidUpdateAuthority', InvalidUpdateAuthorityError);

/** FailedToCreatePubkey: 'Failed to create pubkey' */
export class FailedToCreatePubkeyError extends ProgramError {
  readonly name: string = 'FailedToCreatePubkey';

  readonly code: number = 0x6; // 6

  constructor(program: Program, cause?: Error) {
    super('Failed to create pubkey', program, cause);
  }
}
codeToErrorMap.set(0x6, FailedToCreatePubkeyError);
nameToErrorMap.set('FailedToCreatePubkey', FailedToCreatePubkeyError);

/** DataTypeMismatch: 'Data type mismatch' */
export class DataTypeMismatchError extends ProgramError {
  readonly name: string = 'DataTypeMismatch';

  readonly code: number = 0x7; // 7

  constructor(program: Program, cause?: Error) {
    super('Data type mismatch', program, cause);
  }
}
codeToErrorMap.set(0x7, DataTypeMismatchError);
nameToErrorMap.set('DataTypeMismatch', DataTypeMismatchError);

/** ConstraintAlreadyExists: 'Constraint already exists' */
export class ConstraintAlreadyExistsError extends ProgramError {
  readonly name: string = 'ConstraintAlreadyExists';

  readonly code: number = 0x8; // 8

  constructor(program: Program, cause?: Error) {
    super('Constraint already exists', program, cause);
  }
}
codeToErrorMap.set(0x8, ConstraintAlreadyExistsError);
nameToErrorMap.set('ConstraintAlreadyExists', ConstraintAlreadyExistsError);

/** TokenLimitExceeded: 'Token Limit Exceeded' */
export class TokenLimitExceededError extends ProgramError {
  readonly name: string = 'TokenLimitExceeded';

  readonly code: number = 0x9; // 9

  constructor(program: Program, cause?: Error) {
    super('Token Limit Exceeded', program, cause);
  }
}
codeToErrorMap.set(0x9, TokenLimitExceededError);
nameToErrorMap.set('TokenLimitExceeded', TokenLimitExceededError);

/** FailedToFindTokenAmount: 'Failed to find Token Amount' */
export class FailedToFindTokenAmountError extends ProgramError {
  readonly name: string = 'FailedToFindTokenAmount';

  readonly code: number = 0xa; // 10

  constructor(program: Program, cause?: Error) {
    super('Failed to find Token Amount', program, cause);
  }
}
codeToErrorMap.set(0xa, FailedToFindTokenAmountError);
nameToErrorMap.set('FailedToFindTokenAmount', FailedToFindTokenAmountError);

/** InvalidCollectionMetadata: 'Invalid Collection Metadata' */
export class InvalidCollectionMetadataError extends ProgramError {
  readonly name: string = 'InvalidCollectionMetadata';

  readonly code: number = 0xb; // 11

  constructor(program: Program, cause?: Error) {
    super('Invalid Collection Metadata', program, cause);
  }
}
codeToErrorMap.set(0xb, InvalidCollectionMetadataError);
nameToErrorMap.set('InvalidCollectionMetadata', InvalidCollectionMetadataError);

/** TransferEffectConflict: 'Provided Transfer Effects are not compatible' */
export class TransferEffectConflictError extends ProgramError {
  readonly name: string = 'TransferEffectConflict';

  readonly code: number = 0xc; // 12

  constructor(program: Program, cause?: Error) {
    super('Provided Transfer Effects are not compatible', program, cause);
  }
}
codeToErrorMap.set(0xc, TransferEffectConflictError);
nameToErrorMap.set('TransferEffectConflict', TransferEffectConflictError);

/** FreezeAuthorityNotSet: 'Freeze Authority Not Set' */
export class FreezeAuthorityNotSetError extends ProgramError {
  readonly name: string = 'FreezeAuthorityNotSet';

  readonly code: number = 0xd; // 13

  constructor(program: Program, cause?: Error) {
    super('Freeze Authority Not Set', program, cause);
  }
}
codeToErrorMap.set(0xd, FreezeAuthorityNotSetError);
nameToErrorMap.set('FreezeAuthorityNotSet', FreezeAuthorityNotSetError);

/** CannotBurnPrintEdition: 'Cannot burn Print Edition' */
export class CannotBurnPrintEditionError extends ProgramError {
  readonly name: string = 'CannotBurnPrintEdition';

  readonly code: number = 0xe; // 14

  constructor(program: Program, cause?: Error) {
    super('Cannot burn Print Edition', program, cause);
  }
}
codeToErrorMap.set(0xe, CannotBurnPrintEditionError);
nameToErrorMap.set('CannotBurnPrintEdition', CannotBurnPrintEditionError);

/** ConstraintKeyNotFound: 'Constraint Key Not Found' */
export class ConstraintKeyNotFoundError extends ProgramError {
  readonly name: string = 'ConstraintKeyNotFound';

  readonly code: number = 0xf; // 15

  constructor(program: Program, cause?: Error) {
    super('Constraint Key Not Found', program, cause);
  }
}
codeToErrorMap.set(0xf, ConstraintKeyNotFoundError);
nameToErrorMap.set('ConstraintKeyNotFound', ConstraintKeyNotFoundError);

/** FailedToSerialize: 'Failed to serialize' */
export class FailedToSerializeError extends ProgramError {
  readonly name: string = 'FailedToSerialize';

  readonly code: number = 0x10; // 16

  constructor(program: Program, cause?: Error) {
    super('Failed to serialize', program, cause);
  }
}
codeToErrorMap.set(0x10, FailedToSerializeError);
nameToErrorMap.set('FailedToSerialize', FailedToSerializeError);

/** FailedToBorrowAccountData: 'Failed to borrow account data' */
export class FailedToBorrowAccountDataError extends ProgramError {
  readonly name: string = 'FailedToBorrowAccountData';

  readonly code: number = 0x11; // 17

  constructor(program: Program, cause?: Error) {
    super('Failed to borrow account data', program, cause);
  }
}
codeToErrorMap.set(0x11, FailedToBorrowAccountDataError);
nameToErrorMap.set('FailedToBorrowAccountData', FailedToBorrowAccountDataError);

/** InvalidCollection: 'Failed to deserialize collection' */
export class InvalidCollectionError extends ProgramError {
  readonly name: string = 'InvalidCollection';

  readonly code: number = 0x12; // 18

  constructor(program: Program, cause?: Error) {
    super('Failed to deserialize collection', program, cause);
  }
}
codeToErrorMap.set(0x12, InvalidCollectionError);
nameToErrorMap.set('InvalidCollection', InvalidCollectionError);

/** MustBeHolder: 'Only the holder is allowed to perform this action' */
export class MustBeHolderError extends ProgramError {
  readonly name: string = 'MustBeHolder';

  readonly code: number = 0x13; // 19

  constructor(program: Program, cause?: Error) {
    super('Only the holder is allowed to perform this action', program, cause);
  }
}
codeToErrorMap.set(0x13, MustBeHolderError);
nameToErrorMap.set('MustBeHolder', MustBeHolderError);

/** InvalidFirstCreator: 'Failed to deserialize the first creator' */
export class InvalidFirstCreatorError extends ProgramError {
  readonly name: string = 'InvalidFirstCreator';

  readonly code: number = 0x14; // 20

  constructor(program: Program, cause?: Error) {
    super('Failed to deserialize the first creator', program, cause);
  }
}
codeToErrorMap.set(0x14, InvalidFirstCreatorError);
nameToErrorMap.set('InvalidFirstCreator', InvalidFirstCreatorError);

/** IncorrectOwner: 'Incorrect account owner' */
export class IncorrectOwnerError extends ProgramError {
  readonly name: string = 'IncorrectOwner';

  readonly code: number = 0x15; // 21

  constructor(program: Program, cause?: Error) {
    super('Incorrect account owner', program, cause);
  }
}
codeToErrorMap.set(0x15, IncorrectOwnerError);
nameToErrorMap.set('IncorrectOwner', IncorrectOwnerError);

/** DerivedKeyInvalid: 'Derived key invalid' */
export class DerivedKeyInvalidError extends ProgramError {
  readonly name: string = 'DerivedKeyInvalid';

  readonly code: number = 0x16; // 22

  constructor(program: Program, cause?: Error) {
    super('Derived key invalid', program, cause);
  }
}
codeToErrorMap.set(0x16, DerivedKeyInvalidError);
nameToErrorMap.set('DerivedKeyInvalid', DerivedKeyInvalidError);

/** KeyMismatch: 'Public key does not match expected value' */
export class KeyMismatchError extends ProgramError {
  readonly name: string = 'KeyMismatch';

  readonly code: number = 0x17; // 23

  constructor(program: Program, cause?: Error) {
    super('Public key does not match expected value', program, cause);
  }
}
codeToErrorMap.set(0x17, KeyMismatchError);
nameToErrorMap.set('KeyMismatch', KeyMismatchError);

/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 */
export function getMplTrifleErrorFromCode(
  code: number,
  program: Program,
  cause?: Error
): ProgramError | null {
  const constructor = codeToErrorMap.get(code);
  return constructor ? new constructor(program, cause) : null;
}

/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 */
export function getMplTrifleErrorFromName(
  name: string,
  program: Program,
  cause?: Error
): ProgramError | null {
  const constructor = nameToErrorMap.get(name);
  return constructor ? new constructor(program, cause) : null;
}
